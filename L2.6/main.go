package main

import (
	"fmt"
)

// Что выведет программа?
// Объяснить поведение срезов при передаче их в функцию.

func main() {
	// Создается слайс из 3 строк.
	// Выглядит как-то так:
	// type struct s {
	// pointer *(указатель на массив, где хранятся эти 3 элемента)
	// len 3
	// capacity 3
	//  }
	var s = []string{"1", "2", "3"}

	// Передаем слайс в функцию, передается по значению, то есть копируется.
	// Важно отметить, что передается именно структура,
	// которую из себя и представляет слайс, а не массив. То есть какой бы огромный
	// ни был массив, копируются только 24 байта (указатель и 2 инта по 8 байт)
	modifySlice(s)

	// Выводим слайс
	// {"3", "2", "3"}, len = 3, cap = 3
	fmt.Println(s)
}

func modifySlice(i []string) {
	// Меняем первый элемент в массиве, на который указывает слайс.
	// Получаем: {"3", "2", "3"}, len = 3, cap = 3
	i[0] = "3"

	// Так как capacity не хватает для того чтобы добавить новый элемент,
	// Происходит аллокация нового массива, и с этого момента
	// этот слайс получает новый указатель, куда копируется исходный
	// массив и добавляется новый элемент.
	// len увеличивается на количество добавленных элементов(1)
	// cap на данных оборотах увеличивается в 2 раза
	// {"3", "2", "3", "4"}, len = 4, cap = 6

	// Еще раз важно уточнить, что с этого момента слайс указывает на
	// другой массив и никакие изменения на исходный уже не повлияют.
	// Соответственно теперь все, что будет в "modifySlice", остается в "modifySlice"
	i = append(i, "4")

	// Просто меняем второй элемент в массиве. Но, как и говорилось выше,
	// в массиве новом. Старый массив об этих изменениях даже не догадывается
	// {"3", "5", "3", "4"}, len = 4, cap = 6
	i[1] = "5"

	// Еще один аппенд. Здесь cap хватает, поэтому просто увеличивается len на 1
	// и добавляется новый элемент
	// {"3", "5", "3", "4", "6"}, len = 5, cap = 6
	i = append(i, "6")

	// В итоге получаем такого вида слайс:
	// {"3", "5", "3", "4", "6"}, len = 5, cap = 6

	// Но при этом слайс за пределами функции будет выглядеть так:
	// {"3", "2", "3"}, len = 3, cap = 3
	// Все что изменилось, это первый элемент массива. Дальше произошел
	// append и выделился новый массив для локального слайса.
	// Так как слайс передается по значению, то len и cap копируются,
	// то есть и они никак не меняются за пределами функции
}
